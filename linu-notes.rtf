{\rtf1\ansi\ansicpg1252\deff0\deflang1033{\fonttbl{\f0\fnil\fcharset0 Calibri;}}
{\*\generator Msftedit 5.41.21.2510;}\viewkind4\uc1\pard\ri-1800\sl240\slmult1\lang9\f0\fs22\par
\trowd\trgaph30\trleft-30\trrh256\trpaddl30\trpaddr30\trpaddfl3\trpaddfr3
\clvertalb\cellx13500\pard\intbl\b General Questions:Linux OS\cell\row\trowd\trgaph30\trleft-30\trrh734\trpaddl30\trpaddr30\trpaddfl3\trpaddfr3
\clvertalb\cellx13500\pard\intbl\i\fs24 1. Can a thread acquire more than one lock (Mutex)?\cell\row\trowd\trgaph30\trleft-30\trrh899\trpaddl30\trpaddr30\trpaddfl3\trpaddfr3
\clvertalb\cellx13500\pard\intbl\b0\i0 Yes, it is possible that a thread is in need of more than one resource, hence the locks. If any lock is not available the thread will wait (block)\~on the lock.\cell\row\trowd\trgaph30\trleft-30\trrh614\trpaddl30\trpaddr30\trpaddfl3\trpaddfr3
\clvertalb\cellx13500\pard\intbl\b\i 2. Can a mutex be locked more than once?\cell\row\trowd\trgaph30\trleft-30\trrh929\trpaddl30\trpaddr30\trpaddfl3\trpaddfr3
\clvertalb\cellx13500\pard\intbl\b0\i0 A mutex is a lock. Only one state (locked/unlocked) is associated with it. However, a recursive mutex can be locked more than once (POSIX complaint systems), in which a count is associated with it, yet retains only one state (locked/unlocked). The programmer must unlock the mutex as many number times as it was locked.\cell\row\trowd\trgaph30\trleft-30\trrh644\trpaddl30\trpaddr30\trpaddfl3\trpaddfr3
\clvertalb\cellx13500\pard\intbl\b\i 3. What happens if a non-recursive mutex is locked more than once.\cell\row\trowd\trgaph30\trleft-30\trrh1004\trpaddl30\trpaddr30\trpaddfl3\trpaddfr3
\clvertalb\cellx13500\pard\intbl\b0\i0 Deadlock. If a thread which had already locked a mutex, tries to lock the mutex again, it will enter into the\~waiting\~list of that mutex, which results in deadlock. It is because no other thread can unlock the mutex. An operating system implementer can exercise care in identifying the owner of mutex and return if it is already locked by same thread to prevent deadlocks.\cell\row\trowd\trgaph30\trleft-30\trrh419\trpaddl30\trpaddr30\trpaddfl3\trpaddfr3
\clvertalb\cellx13500\pard\intbl\b\i 4. Are binary semaphore and mutex same?\cell\row\trowd\trgaph30\trleft-30\trrh899\trpaddl30\trpaddr30\trpaddfl3\trpaddfr3
\clvertalb\cellx13500\pard\intbl\b0\i0 No. We suggest to treat them\~separately, as it is explained signalling vs locking\~mechanisms. But a binary semaphore may experience the same critical issues (e.g. priority inversion) associated with mutex. We will cover these in later article.\cell\row\trowd\trgaph30\trleft-30\trrh524\trpaddl30\trpaddr30\trpaddfl3\trpaddfr3
\clvertalb\cellx13500\pard\intbl A programmer can prefer mutex rather than creating a semaphore with count 1.\cell\row\trowd\trgaph30\trleft-30\trrh644\trpaddl30\trpaddr30\trpaddfl3\trpaddfr3
\clvertalb\cellx13500\pard\intbl\b\i 5. What is a mutex and critical section?\cell\row\trowd\trgaph30\trleft-30\trrh1499\trpaddl30\trpaddr30\trpaddfl3\trpaddfr3
\clvertalb\cellx13500\pard\intbl\b0\i0 Some operating systems use the same word critical section in the API. Usually a mutex is costly\~operation\~due to protection protocols associated with it. At last, the objective of mutex is atomic access. There are other ways to achieve atomic access like disabling interrupts which can be much faster but ruins responsiveness. The alternate API makes use of disabling interrupts.\cell\row\trowd\trgaph30\trleft-30\trrh256\trpaddl30\trpaddr30\trpaddfl3\trpaddfr3
\clvertalb\cellx13500\pard\intbl\b\i 6. What are events?\cell\row\trowd\trgaph30\trleft-30\trrh929\trpaddl30\trpaddr30\trpaddfl3\trpaddfr3
\clvertalb\cellx13500\pard\intbl\b0\i0 The semantics of mutex, semaphore, event, critical section, etc\'85 are same. All are synchronization primitives. Based on their cost in using them they are different. We should consult the OS documentation for exact details.\cell\row\trowd\trgaph30\trleft-30\trrh644\trpaddl30\trpaddr30\trpaddfl3\trpaddfr3
\clvertalb\cellx13500\pard\intbl\b\i 7. Can we acquire mutex/semaphore in an Interrupt Service Routine?\cell\row\trowd\trgaph30\trleft-30\trrh974\trpaddl30\trpaddr30\trpaddfl3\trpaddfr3
\clvertalb\cellx13500\pard\intbl\b0\i0 An ISR will run\~asynchronously\~in the context of current running thread. It is not recommended to query (blocking call) the availability of synchronization primitives in an ISR. The ISR are meant be short, the call to mutex/semaphore may block the current running thread. However, an ISR can signal a semaphore or unlock a mutex.\cell\row\trowd\trgaph30\trleft-30\trrh479\trpaddl30\trpaddr30\trpaddfl3\trpaddfr3
\clvertalb\cellx13500\pard\intbl\b\i 8. What we mean by \ldblquote thread blocking on mutex/semaphore\rdblquote  when they are not available?\cell\row\trowd\trgaph30\trleft-30\trrh959\trpaddl30\trpaddr30\trpaddfl3\trpaddfr3
\clvertalb\cellx13500\pard\intbl\b0\i0 Every synchronization primitive has a waiting list associated with it. When the resource is not available, the requesting thread will be moved from the running list of processor to the waiting list of the synchronization primitive. When the resource is available, the higher priority thread on the waiting list gets the resource (more precisely, it depends on the scheduling policies).\cell\row\trowd\trgaph30\trleft-30\trrh509\trpaddl30\trpaddr30\trpaddfl3\trpaddfr3
\clvertalb\cellx13500\pard\intbl\b\i 9. Is it necessary that a thread must block always when resource is not available?\cell\row\trowd\trgaph30\trleft-30\trrh749\trpaddl30\trpaddr30\trpaddfl3\trpaddfr3
\clvertalb\cellx13500\pard\intbl\b0\i0 Not\~necessary. If the design is sure \lquote what has to be done when resource is not available\lquote , the thread can take up that work (a different code branch). To support application requirements the OS provides non-blocking API.\cell\row\trowd\trgaph30\trleft-30\trrh1229\trpaddl30\trpaddr30\trpaddfl3\trpaddfr3
\clvertalb\cellx13500\pard\intbl For example POSIX pthread_mutex_trylock() API. When mutex is not available the function returns immediately whereas the API pthread_mutex_lock() blocks the thread till resource is available.\cell\row\trowd\trgaph30\trleft-30\trpaddl30\trpaddr30\trpaddfl3\trpaddfr3
\clvertalb\cellx13500\pard\intbl\cell\row\trowd\trgaph30\trleft-30\trpaddl30\trpaddr30\trpaddfl3\trpaddfr3
\clvertalb\cellx13500\pard\intbl\cell\row\trowd\trgaph30\trleft-30\trrh256\trpaddl30\trpaddr30\trpaddfl3\trpaddfr3
\clvertalb\cellx13500\pard\intbl\cell\row\trowd\trgaph30\trleft-30\trrh347\trpaddl30\trpaddr30\trpaddfl3\trpaddfr3
\clvertalb\cellx13500\pard\intbl\b Linux Platform device driver: ww.codeproject.com\cell\row\trowd\trgaph30\trleft-30\trrh256\trpaddl30\trpaddr30\trpaddfl3\trpaddfr3
\clvertalb\cellx13500\pard\intbl\b0\cell\row\trowd\trgaph30\trleft-30\trrh394\trpaddl30\trpaddr30\trpaddfl3\trpaddfr3
\clvertalb\cellx13500\pard\intbl\b Introduction\cell\row\trowd\trgaph30\trleft-30\trrh899\trpaddl30\trpaddr30\trpaddfl3\trpaddfr3
\clvertalb\cellx13500\pard\intbl\b0 A platform device is one which is hardwired on the board and hence not hot-pluggable. The driver for this device need not check for the presence of the device and can just go on and do what is required to enable the device to make it operational. If the device is not found, the driver is simply ignored.\cell\row\trowd\trgaph30\trleft-30\trrh319\trpaddl30\trpaddr30\trpaddfl3\trpaddfr3
\clvertalb\cellx13500\pard\intbl\b Background\cell\row\trowd\trgaph30\trleft-30\trrh1459\trpaddl30\trpaddr30\trpaddfl3\trpaddfr3
\clvertalb\cellx13500\pard\intbl\b0 Platform device driver works a bit differently than normal hot-pluggable device driver. Platform device is either directly mounted on the board or part of the SoC and hence can't be physically removed. Compared to hot-pluggable devices, platform device might require some extra settings like gpios pin muxing, power on & reset using gpio control, initializing the clock source, etc., which are very specific to the board or SoC - hence the name platform device driver. This tip gives a brief overview of how to write a platform device driver for Linux.\cell\row\trowd\trgaph30\trleft-30\trrh319\trpaddl30\trpaddr30\trpaddfl3\trpaddfr3
\clvertalb\cellx13500\pard\intbl\b Using the Code\cell\row\trowd\trgaph30\trleft-30\trrh1179\trpaddl30\trpaddr30\trpaddfl3\trpaddfr3
\clvertalb\cellx13500\pard\intbl\b0 The source code for this article is given for reference. The platform device code is usually part of the BSP/CSP. The device driver code is written as a separate module in the appropriate linux-kernel-src/driver/ directory (char for serial device, net for networking device, etc). In the given example code, both the platform device and platform driver code are presented in a single file for easy viewing of the code.\cell\row\trowd\trgaph30\trleft-30\trrh319\trpaddl30\trpaddr30\trpaddfl3\trpaddfr3
\clvertalb\cellx13500\pard\intbl\b Platform Data\cell\row\trowd\trgaph30\trleft-30\trrh1759\trpaddl30\trpaddr30\trpaddfl3\trpaddfr3
\clvertalb\cellx13500\pard\intbl\b0 This structure is specific to the platform device. As indicated in the previous section, since platform device is usually part of the BSP/CSP, this data structure apart from class specific device data, will contain platform specific data such as gpios used, irq number (if interrupt is used), clock frequency settings required by the platform device etc. It usually implements functions that can be called by the device driver for doing platform specific stuff. This way, the device driver can be made independent of the platform and hence can be used across multiple platforms. For example, the below example implements functions for power ON/OFF the device and for doing the device reset.\cell\row\trowd\trgaph30\trleft-30\trrh319\trpaddl30\trpaddr30\trpaddfl3\trpaddfr3
\clvertalb\cellx13500\pard\intbl Hide \~ Copy Code/* Data structure for the platform data of "my device" */\cell\row\trowd\trgaph30\trleft-30\trrh319\trpaddl30\trpaddr30\trpaddfl3\trpaddfr3
\clvertalb\cellx13500\pard\intbl struct my_device_platform_data \{\cell\row\trowd\trgaph30\trleft-30\trrh319\trpaddl30\trpaddr30\trpaddfl3\trpaddfr3
\clvertalb\cellx13500\pard\intbl     int reset_gpio;\cell\row\trowd\trgaph30\trleft-30\trrh319\trpaddl30\trpaddr30\trpaddfl3\trpaddfr3
\clvertalb\cellx13500\pard\intbl     int power_on_gpio;\cell\row\trowd\trgaph30\trleft-30\trrh319\trpaddl30\trpaddr30\trpaddfl3\trpaddfr3
\clvertalb\cellx13500\pard\intbl     void (*power_on)(struct my_device_platform_data* ppdata);\cell\row\trowd\trgaph30\trleft-30\trrh319\trpaddl30\trpaddr30\trpaddfl3\trpaddfr3
\clvertalb\cellx13500\pard\intbl     void (*power_off)(struct my_device_platform_data* ppdata);\cell\row\trowd\trgaph30\trleft-30\trrh319\trpaddl30\trpaddr30\trpaddfl3\trpaddfr3
\clvertalb\cellx13500\pard\intbl     void (*reset)(struct my_device_platform_data* pdata);\cell\row\trowd\trgaph30\trleft-30\trrh319\trpaddl30\trpaddr30\trpaddfl3\trpaddfr3
\clvertalb\cellx13500\pard\intbl\};\cell\row\trowd\trgaph30\trleft-30\trrh319\trpaddl30\trpaddr30\trpaddfl3\trpaddfr3
\clvertalb\cellx13500\pard\intbl /* "my device" platform data */\cell\row\trowd\trgaph30\trleft-30\trrh319\trpaddl30\trpaddr30\trpaddfl3\trpaddfr3
\clvertalb\cellx13500\pard\intbl static struct my_device_platform_data my_device_pdata = \{\cell\row\trowd\trgaph30\trleft-30\trrh319\trpaddl30\trpaddr30\trpaddfl3\trpaddfr3
\clvertalb\cellx13500\pard\intbl     .reset_gpio         = 100,\cell\row\trowd\trgaph30\trleft-30\trrh319\trpaddl30\trpaddr30\trpaddfl3\trpaddfr3
\clvertalb\cellx13500\pard\intbl     .power_on_gpio      = 101,\cell\row\trowd\trgaph30\trleft-30\trrh319\trpaddl30\trpaddr30\trpaddfl3\trpaddfr3
\clvertalb\cellx13500\pard\intbl     .power_on           = my_device_power_on,\cell\row\trowd\trgaph30\trleft-30\trrh319\trpaddl30\trpaddr30\trpaddfl3\trpaddfr3
\clvertalb\cellx13500\pard\intbl     .power_off          = my_device_power_off,\cell\row\trowd\trgaph30\trleft-30\trrh319\trpaddl30\trpaddr30\trpaddfl3\trpaddfr3
\clvertalb\cellx13500\pard\intbl     .reset              = my_device_reset\cell\row\trowd\trgaph30\trleft-30\trrh319\trpaddl30\trpaddr30\trpaddfl3\trpaddfr3
\clvertalb\cellx13500\pard\intbl\}; \cell\row\trowd\trgaph30\trleft-30\trrh319\trpaddl30\trpaddr30\trpaddfl3\trpaddfr3
\clvertalb\cellx13500\pard\intbl\b Registering Platform Device\cell\row\trowd\trgaph30\trleft-30\trrh899\trpaddl30\trpaddr30\trpaddfl3\trpaddfr3
\clvertalb\cellx13500\pard\intbl\b0 This is done by calling platform_device_register() function with the device instance as shown below. The name of the device is very important as this string is used by the OS for calling the probe() function when the corresponding driver is installed. Please note that this function must be called before registering Platform Driver.\cell\row\trowd\trgaph30\trleft-30\trrh319\trpaddl30\trpaddr30\trpaddfl3\trpaddfr3
\clvertalb\cellx13500\pard\intbl Hide \~ Copy Codestatic struct platform_device my_device = \{\cell\row\trowd\trgaph30\trleft-30\trrh319\trpaddl30\trpaddr30\trpaddfl3\trpaddfr3
\clvertalb\cellx13500\pard\intbl     .name                 = "my-platform-device",\cell\row\trowd\trgaph30\trleft-30\trrh319\trpaddl30\trpaddr30\trpaddfl3\trpaddfr3
\clvertalb\cellx13500\pard\intbl     .id                   = PLATFORM_DEVID_NONE,\cell\row\trowd\trgaph30\trleft-30\trrh319\trpaddl30\trpaddr30\trpaddfl3\trpaddfr3
\clvertalb\cellx13500\pard\intbl     .dev.platform_data    = &my_device_pdata\cell\row\trowd\trgaph30\trleft-30\trrh319\trpaddl30\trpaddr30\trpaddfl3\trpaddfr3
\clvertalb\cellx13500\pard\intbl\};\cell\row\trowd\trgaph30\trleft-30\trrh319\trpaddl30\trpaddr30\trpaddfl3\trpaddfr3
\clvertalb\cellx13500\pard\intbl platform_device_register(&my_device); \cell\row\trowd\trgaph30\trleft-30\trrh319\trpaddl30\trpaddr30\trpaddfl3\trpaddfr3
\clvertalb\cellx13500\pard\intbl\b Platform Driver\cell\row\trowd\trgaph30\trleft-30\trrh879\trpaddl30\trpaddr30\trpaddfl3\trpaddfr3
\clvertalb\cellx13500\pard\intbl\b0 The platform driver implements a probe function that is called by the OS when this driver is inserted. Since the driver is supposed to be platform independent, it depends on the platform_data functions to set up the device and make it operational.\cell\row\trowd\trgaph30\trleft-30\trrh319\trpaddl30\trpaddr30\trpaddfl3\trpaddfr3
\clvertalb\cellx13500\pard\intbl Hide \~ Copy Codestatic struct platform_driver my_driver = \{\cell\row\trowd\trgaph30\trleft-30\trrh319\trpaddl30\trpaddr30\trpaddfl3\trpaddfr3
\clvertalb\cellx13500\pard\intbl     .probe      = my_driver_probe,\cell\row\trowd\trgaph30\trleft-30\trrh319\trpaddl30\trpaddr30\trpaddfl3\trpaddfr3
\clvertalb\cellx13500\pard\intbl     .remove     = my_driver_remove,\cell\row\trowd\trgaph30\trleft-30\trrh319\trpaddl30\trpaddr30\trpaddfl3\trpaddfr3
\clvertalb\cellx13500\pard\intbl     .driver     = \{\cell\row\trowd\trgaph30\trleft-30\trrh319\trpaddl30\trpaddr30\trpaddfl3\trpaddfr3
\clvertalb\cellx13500\pard\intbl         .name     = "my-platform-device",\cell\row\trowd\trgaph30\trleft-30\trrh319\trpaddl30\trpaddr30\trpaddfl3\trpaddfr3
\clvertalb\cellx13500\pard\intbl         .owner    = THIS_MODULE,\cell\row\trowd\trgaph30\trleft-30\trrh319\trpaddl30\trpaddr30\trpaddfl3\trpaddfr3
\clvertalb\cellx13500\pard\intbl         .pm       = &my_device_pm_ops,\cell\row\trowd\trgaph30\trleft-30\trrh319\trpaddl30\trpaddr30\trpaddfl3\trpaddfr3
\clvertalb\cellx13500\pard\intbl     \},\cell\row\trowd\trgaph30\trleft-30\trrh319\trpaddl30\trpaddr30\trpaddfl3\trpaddfr3
\clvertalb\cellx13500\pard\intbl\}; \cell\row\trowd\trgaph30\trleft-30\trrh319\trpaddl30\trpaddr30\trpaddfl3\trpaddfr3
\clvertalb\cellx13500\pard\intbl\b Registering Platform Driver\cell\row\trowd\trgaph30\trleft-30\trrh2279\trpaddl30\trpaddr30\trpaddfl3\trpaddfr3
\clvertalb\cellx13500\pard\intbl\b0 Here is the function for registering driver with the OS. Please note that we are using platform_driver_probe() instead of platform_driver_register(), since we know that this device is present for sure in the system. The difference between these two functions is that with platform_driver_register(), we are asking the OS to put this driver in the list of drivers it maintains for doing device to driver matching when the devices come in/out of the system. Since platform devices are either always present always absent in system (and not-hot-pluggable), we don't need to put our platform driver in the OS driver list. With platform_driver_probe(), we are asking the OS to check if a platform device is present with the matching name. If the device is present in the system, the corresponding probe() function is called. If not present, the driver is simply ignored.\cell\row\trowd\trgaph30\trleft-30\trrh319\trpaddl30\trpaddr30\trpaddfl3\trpaddfr3
\clvertalb\cellx13500\pard\intbl Hide \~ Copy Coderet = platform_driver_probe(&my_driver, my_driver_probe);\cell\row\trowd\trgaph30\trleft-30\trrh319\trpaddl30\trpaddr30\trpaddfl3\trpaddfr3
\clvertalb\cellx13500\pard\intbl\b Platform Device and Driver binding\cell\row\trowd\trgaph30\trleft-30\trrh1179\trpaddl30\trpaddr30\trpaddfl3\trpaddfr3
\clvertalb\cellx13500\pard\intbl\b0 When the platform_driver_probe() function is called, the operating system scans through the list of available platform devices and checks if the driver.name matches with the device name. If yes, it calls the driver probe function with the platform data. The probe function can then initialize the clock settings, power-on, reset the device, allocated the driver data and register the corresponding class specific driver with the OS.\cell\row\trowd\trgaph30\trleft-30\trrh319\trpaddl30\trpaddr30\trpaddfl3\trpaddfr3
\clvertalb\cellx13500\pard\intbl Hide \~ Shrink \~ Copy Codestatic int my_driver_probe(struct platform_device *pdev)\cell\row\trowd\trgaph30\trleft-30\trrh319\trpaddl30\trpaddr30\trpaddfl3\trpaddfr3
\clvertalb\cellx13500\pard\intbl\{\cell\row\trowd\trgaph30\trleft-30\trrh319\trpaddl30\trpaddr30\trpaddfl3\trpaddfr3
\clvertalb\cellx13500\pard\intbl     struct my_device_platform_data *my_device_pdata;\cell\row\trowd\trgaph30\trleft-30\trrh319\trpaddl30\trpaddr30\trpaddfl3\trpaddfr3
\clvertalb\cellx13500\pard\intbl     struct my_driver_data* driver_data;\cell\row\trowd\trgaph30\trleft-30\trrh319\trpaddl30\trpaddr30\trpaddfl3\trpaddfr3
\clvertalb\cellx13500\pard\intbl     printk(KERN_ALERT " %s\\n", __FUNCTION__);\cell\row\trowd\trgaph30\trleft-30\trrh319\trpaddl30\trpaddr30\trpaddfl3\trpaddfr3
\clvertalb\cellx13500\pard\intbl     my_device_pdata = dev_get_platdata(&pdev->dev);\cell\row\trowd\trgaph30\trleft-30\trrh319\trpaddl30\trpaddr30\trpaddfl3\trpaddfr3
\clvertalb\cellx13500\pard\intbl     /* Power on the device. */\cell\row\trowd\trgaph30\trleft-30\trrh319\trpaddl30\trpaddr30\trpaddfl3\trpaddfr3
\clvertalb\cellx13500\pard\intbl     if (my_device_pdata->power_on) \{\cell\row\trowd\trgaph30\trleft-30\trrh319\trpaddl30\trpaddr30\trpaddfl3\trpaddfr3
\clvertalb\cellx13500\pard\intbl         my_device_pdata->power_on(my_device_pdata);\cell\row\trowd\trgaph30\trleft-30\trrh319\trpaddl30\trpaddr30\trpaddfl3\trpaddfr3
\clvertalb\cellx13500\pard\intbl     \}\cell\row\trowd\trgaph30\trleft-30\trrh319\trpaddl30\trpaddr30\trpaddfl3\trpaddfr3
\clvertalb\cellx13500\pard\intbl     /* wait for some time before we do the reset */\cell\row\trowd\trgaph30\trleft-30\trrh319\trpaddl30\trpaddr30\trpaddfl3\trpaddfr3
\clvertalb\cellx13500\pard\intbl     mdelay(5);\cell\row\trowd\trgaph30\trleft-30\trrh319\trpaddl30\trpaddr30\trpaddfl3\trpaddfr3
\clvertalb\cellx13500\pard\intbl     /* Reset the device. */\cell\row\trowd\trgaph30\trleft-30\trrh319\trpaddl30\trpaddr30\trpaddfl3\trpaddfr3
\clvertalb\cellx13500\pard\intbl     if (my_device_pdata->reset) \{\cell\row\trowd\trgaph30\trleft-30\trrh319\trpaddl30\trpaddr30\trpaddfl3\trpaddfr3
\clvertalb\cellx13500\pard\intbl         my_device_pdata->reset(my_device_pdata);\cell\row\trowd\trgaph30\trleft-30\trrh319\trpaddl30\trpaddr30\trpaddfl3\trpaddfr3
\clvertalb\cellx13500\pard\intbl     \}\cell\row\trowd\trgaph30\trleft-30\trrh319\trpaddl30\trpaddr30\trpaddfl3\trpaddfr3
\clvertalb\cellx13500\pard\intbl     /* Create the driver data here */\cell\row\trowd\trgaph30\trleft-30\trrh319\trpaddl30\trpaddr30\trpaddfl3\trpaddfr3
\clvertalb\cellx13500\pard\intbl     driver_data = kzalloc(sizeof(struct my_driver_data), GFP_KERNEL);\cell\row\trowd\trgaph30\trleft-30\trrh319\trpaddl30\trpaddr30\trpaddfl3\trpaddfr3
\clvertalb\cellx13500\pard\intbl     if(!driver_data)\cell\row\trowd\trgaph30\trleft-30\trrh319\trpaddl30\trpaddr30\trpaddfl3\trpaddfr3
\clvertalb\cellx13500\pard\intbl         return -ENOMEM;\cell\row\trowd\trgaph30\trleft-30\trrh319\trpaddl30\trpaddr30\trpaddfl3\trpaddfr3
\clvertalb\cellx13500\pard\intbl     /* Set this driver data in platform device structure */\cell\row\trowd\trgaph30\trleft-30\trrh319\trpaddl30\trpaddr30\trpaddfl3\trpaddfr3
\clvertalb\cellx13500\pard\intbl     platform_set_drvdata(pdev, driver_data);\cell\row\trowd\trgaph30\trleft-30\trrh319\trpaddl30\trpaddr30\trpaddfl3\trpaddfr3
\clvertalb\cellx13500\pard\intbl    \cell\row\trowd\trgaph30\trleft-30\trrh319\trpaddl30\trpaddr30\trpaddfl3\trpaddfr3
\clvertalb\cellx13500\pard\intbl     /* Call the class specific register driver here */\cell\row\trowd\trgaph30\trleft-30\trrh319\trpaddl30\trpaddr30\trpaddfl3\trpaddfr3
\clvertalb\cellx13500\pard\intbl     // tty_register_driver(ttyprintk_driver); // for UART driver\cell\row\trowd\trgaph30\trleft-30\trrh319\trpaddl30\trpaddr30\trpaddfl3\trpaddfr3
\clvertalb\cellx13500\pard\intbl     // register_netdev(net_driver); // for Net driver \cell\row\trowd\trgaph30\trleft-30\trrh319\trpaddl30\trpaddr30\trpaddfl3\trpaddfr3
\clvertalb\cellx13500\pard\intbl     // sdio_register_driver(sdio_river)\cell\row\trowd\trgaph30\trleft-30\trrh319\trpaddl30\trpaddr30\trpaddfl3\trpaddfr3
\clvertalb\cellx13500\pard\intbl     return 0;\cell\row\trowd\trgaph30\trleft-30\trrh319\trpaddl30\trpaddr30\trpaddfl3\trpaddfr3
\clvertalb\cellx13500\pard\intbl\} \cell\row\pard\sl240\slmult1\fs22\par
}
 